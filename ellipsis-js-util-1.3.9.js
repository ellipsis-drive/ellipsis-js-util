!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.EllipsisUtil=e():t.EllipsisUtil=e()}(self,(()=>(()=>{"use strict";var t={d:(e,i)=>{for(var o in i)t.o(i,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:i[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{EllipsisApi:()=>r,RasterLayerUtil:()=>o,VectorLayerUtil:()=>i});var i={};t.r(i),t.d(i,{EllipsisVectorLayerBase:()=>p,defaultStyle:()=>f,extractStyling:()=>y,getFeatureStyling:()=>I,getStyleKeys:()=>m,parseHex:()=>g});var o={};t.r(o),t.d(o,{getLayerId:()=>T,getSlippyMapUrl:()=>b,getSlippyMapUrlWithDefaults:()=>v});let s="https://api.ellipsis-drive.com/v3";function a(t,e){const i=Error.call(this,e);this.name="API Error",this.message=i.message,this.stack=i.stack,this.status=t}function n(t,e=!1){Object.entries(t).forEach((([e,i])=>{"object"==typeof i&&(t[e]=JSON.stringify(i)),null==i&&delete t[e]}));const i=new URLSearchParams(t).toString();return e?i:""===i?"":"?"+i}async function l(t,e,i,o,l){let r={"Content-Type":"application/json"};o&&(r.Authorization=`Bearer ${o.token}`);const d="HEAD"===t||"GET"===t||"DELETE"===t,h=n(d?{mapId:o?.mapId,...i}:{mapId:o?.mapId}),p=`${l??s}${e}${h}`;let c=null,f=!1,u=!1,m={method:t,headers:r};return i&&!d&&(m.body=JSON.stringify(i)),await fetch(p,m).then((t=>{t.ok||429===t.status&&alert("You made too many calls to this map and won't be able to use it for another minute. Contact the owner of this map to give you more bandwidth."),c=t;let e=t.headers.get("Content-Type");return e?(f=e.includes("text"),u=e.includes("application/json")):f=!0,u?t.json():f?t.text():t.blob()})).then((t=>{if(200===c.status)return t;throw new a(c.status,f?t:t.message)}))}const r={setApiUrl:t=>s=t,apiUrl:s,getApiUrl:()=>s,post:(t,e,i)=>l("POST",t,e,i),get:(t,e,i)=>l("GET",t,e,i),login:(t,e)=>l("POST","/account/login",{username:t,password:e}),getPath:(t,e)=>l("GET",`/path/${t}`,void 0,e),getInfo:(t,e)=>getPath(t,e)};class d extends Error{constructor(t){super(t),this.name="EllipsisVectorLayerError"}}class h{static defaultOptions={centerPoints:!1,pageSize:1e3,chunkSize:10,maxMbPerTile:32,maxRenderTiles:100,maxTilesInCache:500,maxFeaturesPerTile:1e4,fetchInterval:0,levelOfDetailMapper:t=>{const e=[4,6,11,14,17].findIndex((e=>t<e))+1;return 0===e?6:e}};static optionModifiers={pageSize:t=>Math.min(3e3,t),maxMbPerTile:t=>1e6*t,debug:t=>t?t=>console.log(t):()=>{}};loadingState={loadInterrupters:[],loadingTimeout:void 0,cache:{},featuresInTileCache:{},nextPageStart:Array(6),oldTiles:[],isLoading:!1,updateLock:!1,missedCall:!1};info={layerInfo:void 0,style:void 0};tiles=[];zoom=1;loadOptions={styleKeys:void 0,onEachFeature:void 0};getMapBounds=()=>console.error("get map bounds not implemented");updateView=()=>console.error("update view not implemented");constructor(t={}){if(t.pathId||(t.pathId=t.blockId||t.mapId,t.pathId&&console.warn("We recommended to use the property name pathId instead of mapId or blockId to identify ellipsis drive maps to reduce confusion with other libraries.")),!t.pathId)throw new d("You did not specify a path ID.");!t.timestampId&&t.layerId&&(t.timestampId=t.layerId,console.warn("We recommended to use the property name timestampId instead of layerId to identify ellipsis drive timestamps.")),Object.keys(h.defaultOptions).forEach((e=>{null==t[e]&&(t[e]=h.defaultOptions[e])})),Object.keys(h.optionModifiers).forEach((e=>t[e]=h.optionModifiers[e](t[e]))),this.options={},Object.keys(t).forEach((e=>this.options[e]=t[e])),"string"==typeof this.options.style&&(this.options.styleId=this.options.style,this.options.style=void 0),this.id=`${this.options.pathId}_${this.options.timestampId}`}getLayerInfo=()=>this.info.layerInfo;getTilesAbove=t=>{const e=t.zoom;let i=t.zoom,o=[];for(;i>0;){const s={zoom:i,tileX:Math.floor(t.tileX/2**(e-i)),tileY:Math.floor(t.tileY/2**(e-i))};o.push(s),i-=1}return o};getFeatures=()=>{let t=this.tiles.map((t=>this.getTilesAbove(t)));t=t.flat(),t=[...t,...this.loadingState.oldTiles];let e=t.map((t=>this.getTileId(t)));t=t.filter(((t,i,o)=>e.indexOf(this.getTileId(t))===i)),t.length>this.options.maxRenderTiles&&(t=t.slice(0,this.options.maxRenderTiles)),this.loadingState.oldTiles=t;const i={};return t.flatMap((t=>{const e=this.loadingState.featuresInTileCache[this.getTileId(t)]?.featureIds;return e?e.map((e=>{const o=this.loadingState.cache[e];return o&&o[this.options.levelOfDetailMapper(t.zoom)-1]&&!i[e]?(i[e]=!0,o[this.options.levelOfDetailMapper(t.zoom)-1]):null})).filter((t=>t)):[]}))};clearLayer=async()=>{await this.awaitNotLoading(),this.loadingState.cache={},this.loadingState.featuresInTileCache={},this.loadingState.nextPageStart=Array(6)};update=async()=>{if(this.loadingState.updateLock)return;this.options.debug("update.."),this.info.layerInfo||(this.loadingState.updateLock=!0,await this.fetchLayerInfo(),this.fetchStylingInfo(),this.loadingState.updateLock=!1,this.options.debug("fetched layer info:"),this.options.debug(this.info.layerInfo),this.options.debug("fetched style info:"),this.options.debug(this.info.style));const t=this.getMapBounds();if(!t)return;const e=this.options.maxZoom??this.options.zoom??this.info.layerInfo.zoom;this.zoom=Math.max(Math.min(e,t.zoom-2),0),this.tiles=this.boundsToTiles(t.bounds,this.zoom),this.load((()=>{this.updateView()}),this.options.fetchInterval)};load=async(t,e)=>{if(this.loadingState.loadingTimeout)return;if(this.loadingState.isLoading)return void(this.loadingState.missedCall=!0);this.loadingState.missedCall=!1,this.options.debug("load"),this.loadingState.isLoading=!0;const i=await this.requestTileGeoJsons();return this.loadingState.isLoading=!1,this.loadingState.loadInterrupters.length?(this.loadingState.loadingTimeout=void 0,this.loadingState.loadInterrupters.forEach((t=>t())),void(this.loadingState.loadInterrupters=[])):i||this.loadingState.missedCall?(this.options.debug("loaded new data, page start: "+this.loadingState.nextPageStart),t(),void(this.loadingState.loadingTimeout=setTimeout((()=>{this.loadingState.loadingTimeout=void 0,this.load(t,e)}),e))):(this.options.debug("did not cache new data"),void this.ensureMaxCacheSize())};awaitNotLoading=t=>new Promise(((e,i)=>this.loadingState.loadingTimeout||this.loadingState.isLoading?this.loadingState.isLoading?this.loadingState.loadInterrupters.push((()=>e())):this.loadingState.loadingTimeout?(clearTimeout(this.loadingState.loadingTimeout),this.loadingState.loadingTimeout=void 0,t?e():setTimeout((()=>e()),this.options.fetchInterval)):void i():e()));ensureMaxCacheSize=()=>{};requestTileGeoJsons=async()=>{const t=Date.now(),e=this.tiles.map((t=>{const e=this.getTileId(t);if(this.options.levelOfDetailMapper(t.zoom),!this.loadingState.featuresInTileCache[e])return{tileId:t};const i=this.loadingState.featuresInTileCache[e].nextPageStart;return i&&this.loadingState.featuresInTileCache[e].amount<=this.options.maxFeaturesPerTile&&this.loadingState.featuresInTileCache[e].size<=this.options.maxMbPerTile?{tileId:t,pageStart:i}:null})).filter((t=>t));if(0===e.length)return!1;const i={returnType:this.getReturnType(),zipTheResponse:!0,pageSize:this.options.pageSize,style:this.options.styleId,propertyFilter:this.options.filter&&this.options.filter>0?this.options.filter:null};let o=[];const s=this.options.chunkSize;for(let t=0;t<e.length;t+=s){i.tiles=e.slice(t,t+s);try{const t=await r.get(`/path/${this.options.pathId}/vector/timestamp/${this.info.layerInfo.id}/featuresByTiles`,i,{token:this.options.token});o=o.concat(t)}catch(t){return console.error("an error occured with getting tile features"),console.error(t),!1}}for(let i=0;i<e.length;i++){const s=this.getTileId(e[i].tileId);this.loadingState.featuresInTileCache[s]||(this.loadingState.featuresInTileCache[s]={size:0,amount:0,featureIds:[],nextPageStart:null});const a=this.loadingState.featuresInTileCache[s];a.date=t,a.size=a.size+o[i].size,a.amount=a.amount+o[i].result.features.length,a.levelOfDetail=this.options.levelOfDetailMapper(e[i].zoom),a.nextPageStart=o[i].nextPageStart,o[i].result.features&&o[i].result.features.forEach((t=>{this.compileStyle(t),this.loadOptions.onEachFeature&&this.loadOptions.onEachFeature(t)})),a.featureIds.push(...o[i].result.features.map((t=>t.properties.id))),o[i].result.features.forEach((t=>{const o=t.properties.id;this.loadingState.cache[o]||(this.loadingState.cache[o]=new Array(6)),this.loadingState.cache[o][this.options.levelOfDetailMapper(e[i].tileId.zoom)-1]||(t.lod=this.options.levelOfDetailMapper(e[i].tileId.zoom)-1,this.loadingState.cache[o][this.options.levelOfDetailMapper(e[i].tileId.zoom)-1]=t)}))}return!0};fetchLayerInfo=async()=>{const t=await r.getPath(this.options.pathId,{token:this.options.token});if(!t?.vector?.timestamps?.length)throw new d(`Specified path "${this.options.pathId}" does not contain any data.`);if(t.trashed&&console.warn("Path is trashed."),"vector"!==t.type)throw new d("Path info type is not vector.");const e=t.vector.timestamps;this.info.pathStyles=t.vector.styles;const i=e?.reverse().find((t=>!t.trashed&&!t.availability.blocked&&"active"===t.status));if(!this.options.timestampId&&i)this.info.layerInfo=i,this.options.debug(`No timestamp ID specified. Picked default ${i.id}`);else{const t=e.find((t=>t.id===this.options.timestampId));if(t)this.info.layerInfo=t;else if(!t&&i)this.info.layerInfo=i,this.options.debug(`No correct timestamp ID specified. Picked default ${i.id}`);else if(!t&&!i)throw new d(`Specified timestamp with id=${this.options.timestampId} does not exist and the path has no default timestamp to use as a fallback.`)}};fetchStylingInfo=()=>{const t=m({blacklist:["radius"]});if(!this.options.styleId&&this.options.style)return void(this.info.style=y(this.options.style.parameters,t));if(!this.info.pathStyles?.length)throw this.info.style=void 0,new d("The layer has no style.");const e=this.info.pathStyles.find((t=>t.id===this.options.styleId||t.default&&!this.options.styleId));this.info.style=e&&e.parameters?y(e.parameters,t):void 0};getReturnType=()=>this.options.centerPoints?"center":(this.info.style?.popupProperty,"all");recompileStyles=()=>{this.getFeatures().forEach((t=>this.compileStyle(t)))};compileStyle=t=>{let e=I(t,this.info.style,this.options);e=y(e,this.loadOptions.styleKeys),t.properties||(t.properties={}),t.properties.compiledStyle=e};getTileId=t=>`${t.zoom}_${t.tileX}_${t.tileY}`;boundsToTiles=(t,e)=>{const i=Math.max(t.xMin,-180),o=Math.min(t.xMax,180),s=Math.max(t.yMin,-85),a=Math.min(t.yMax,85),n=Math.pow(2,e),l=n/360,r=Math.PI,d=2*r,h=r/4,p=Math.floor((i+180)*l),c=Math.floor((o+180)*l),f=Math.floor(n/d*(r-Math.log(Math.tan(h+a/360*r)))),u=Math.floor(n/d*(r-Math.log(Math.tan(h+s/360*r))));let m=[];for(let t=Math.max(0,p-1);t<=Math.min(2**e-1,c+1);t++)for(let i=Math.max(0,f-1);i<=Math.min(2**e-1,u+1);i++)m.push({zoom:e,tileX:t,tileY:i});return m}}const p=h,c=(...t)=>{let e=t[t.length-2],i=t[t.length-1];void 0===e&&(e={}),void 0===i&&(i={});const o=Object.fromEntries(Object.keys({...e,...i}).map((t=>[t,void 0===i[t]?e[t]:i[t]])));return t.length>2?c(...t.slice(0,t.length-2),o):o},f={radius:6,width:2,borderColor:"#000000",borderOpacity:1,fillColor:"#000000",fillOpacity:.5},u={radius:[],width:["lineWidth","weight"],borderColor:[],borderOpacity:[],fillColor:["color"],fillOpacity:["opacity"],popupProperty:[]},m=(t={blacklist:[]})=>Object.fromEntries(Object.entries(u).filter((([e])=>!(t.blacklist.includes(e)||t.whitelist&&!t.whitelist.includes(e))))),g=(t,e)=>{if(!t)return;const i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(t);let[o,s,a,n]=i.slice(1).map((t=>parseInt(t,16)));return n=isNaN(n)?n=void 0:n/=255,e?{r:o,g:s,b:a,opacity:n}:{color:`#${i.slice(1,4).join("")}`,opacity:n}},y=(t={},e=u)=>{const i={};return Object.entries(t).forEach((([t,o])=>{const s=Object.entries(e).filter((([e,i])=>e===t||i&&i.includes(t)));s&&s.length&&s.forEach((([t])=>i[t]=o))})),i},I=(t,...e)=>{const i=t&&t.properties?y(t.properties):void 0;let o=c(i,...e.map((t=>t?y(t):void 0))),s=g(o.borderColor),a=g(o.fillColor);return s&&!a&&(a={...s},s.opacity=1),!s&&a&&(s={...a},s.opacity=1),s&&(o=c({fillOpacity:a.opacity,borderOpacity:s.opacity},o,{fillColor:a.color,borderColor:s.color})),c(f,o)};class S extends Error{constructor(t){super(t),this.name="EllipsisRasterLayerError"}}const b=(t={})=>{const e=n({token:t.token,style:t.style??t.layer??t.visualizationId??t.visualization,mask:t.mask});return`${r.getApiUrl()}/path/${t.pathId??t.blockId}/raster/timestamp/${t.timestampId??t.captureId}/tile/{z}/{x}/{y}${e}`},v=async(t={})=>{const e={token:t.token,style:t.style??t.layer??t.visualizationId??t.visualization,mask:t.mask};let i=t.timestampId??t.captureId;const o=t.pathId??t.blockId;let s=t.maxZoom??t.zoom;if(!i||!e.style||!s){const t=await r.getPath(o,{token:e.token});if(!t)throw new S(`Could not fetch data of path with id ${o}`);if("raster"!==t.type)throw new S("Path is not of type raster");if(!i){if(!t.raster?.timestamps?.length)throw new S("There are no timestamps in this path");const e=t.raster.timestamps.reverse().find((t=>!t.availability.blocked&&!t.trashed&&"active"===t.status));if(!e)throw new S("Could not find a valid default timestamp.");i=e.id}if(!s){let e=t.raster.timestamps.find((t=>t.id===i));if(!e)throw new S("Given timestampId does not exist");s=e.zoom}if(!e.style){const i=t.raster.styles?.find((t=>t.default));if(!i)throw new S("No default style found");e.style=i.id}}let a=`${r.getApiUrl()}/path/${o}/raster/timestamp/${i}/tile/{z}/{x}/{y}${n(e)}`;return{zoom:s,url:a,id:a+"_"+s}},T=(t={})=>`${t.pathId??t.blockId}_${t.timestampId??t.captureId}_${encodeURIComponent(JSON.stringify(t.style??t.visualizationId??t.visualization))}`;return e})()));