!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.EllipsisUtil=e():t.EllipsisUtil=e()}(self,(()=>(()=>{"use strict";var t={d:(e,i)=>{for(var o in i)t.o(i,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:i[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{EllipsisApi:()=>r,RasterLayerUtil:()=>o,VectorLayerUtil:()=>i});var i={};t.r(i),t.d(i,{EllipsisVectorLayerBase:()=>p,defaultStyle:()=>f,extractStyling:()=>y,getFeatureStyling:()=>I,getStyleKeys:()=>g,parseHex:()=>m});var o={};t.r(o),t.d(o,{getLayerId:()=>O,getSlippyMapUrl:()=>v,getSlippyMapUrlWithDefaults:()=>b});let a="https://api.ellipsis-drive.com/v3";function s(t,e){const i=Error.call(this,e);this.name="API Error",this.message=i.message,this.stack=i.stack,this.status=t}function l(t,e=!1){Object.entries(t).forEach((([e,i])=>{"object"==typeof i&&(t[e]=JSON.stringify(i)),null==i&&delete t[e]}));const i=new URLSearchParams(t).toString();return e?i:""===i?"":"?"+i}async function n(t,e,i,o,n){let r={"Content-Type":"application/json"};o&&(r.Authorization=`Bearer ${o.token}`);const h="HEAD"===t||"GET"===t||"DELETE"===t,d=l(h?{mapId:o?.mapId,...i}:{mapId:o?.mapId}),p=`${n??a}${e}${d}`;let c=null,f=!1,u=!1,g={method:t,headers:r};return i&&!h&&(g.body=JSON.stringify(i)),await fetch(p,g).then((t=>{t.ok||429===t.status&&alert("You made too many calls to this map and won't be able to use it for another minute. Contact the owner of this map to give you more bandwidth."),c=t;let e=t.headers.get("Content-Type");return e?(f=e.includes("text"),u=e.includes("application/json")):f=!0,u?t.json():f?t.text():t.blob()})).then((t=>{if(200===c.status)return t;throw new s(c.status,f?t:t.message)}))}const r={setApiUrl:t=>a=t,apiUrl:a,getApiUrl:()=>a,post:(t,e,i)=>n("POST",t,e,i),get:(t,e,i)=>n("GET",t,e,i),login:(t,e)=>n("POST","/account/login",{username:t,password:e}),getPath:(t,e)=>n("GET",`/path/${t}`,void 0,e),getInfo:(t,e)=>getPath(t,e)};class h extends Error{constructor(t){super(t),this.name="EllipsisVectorLayerError"}}class d{static defaultOptions={centerPoints:!1,pageSize:50,chunkSize:10,maxMbPerTile:16,maxTilesInCache:500,maxFeaturesPerTile:500,useMarkers:!1,loadAll:!1,fetchInterval:0,levelOfDetailMode:"dynamic",levelOfDetailMapper:t=>{const e=[3,6,9,12,15].findIndex((e=>t<e))+1;return 0===e?6:e},levelOfDetail:6};static optionModifiers={pageSize:t=>Math.min(3e3,t),maxMbPerTile:t=>1e6*t,debug:t=>t?t=>console.log(t):()=>{}};loadingState={loadInterrupters:[],loadingTimeout:void 0,cache:{},featuresInTileCache:{},nextPageStart:Array(6),isLoading:!1,updateLock:!1,missedCall:!1};info={layerInfo:void 0,style:void 0};tiles=[];zoom=1;loadOptions={styleKeys:void 0,onEachFeature:void 0};getMapBounds=()=>console.error("get map bounds not implemented");updateView=()=>console.error("update view not implemented");constructor(t={}){if(t.pathId||(t.pathId=t.blockId||t.mapId,t.pathId&&console.warn("We recommended to use the property name pathId instead of mapId or blockId to identify ellipsis drive maps to reduce confusion with other libraries.")),!t.pathId)throw new h("You did not specify a path ID.");!t.timestampId&&t.layerId&&(t.timestampId=t.layerId,console.warn("We recommended to use the property name timestampId instead of layerId to identify ellipsis drive timestamps.")),Object.keys(d.defaultOptions).forEach((e=>{null==t[e]&&(t[e]=d.defaultOptions[e])})),Object.keys(d.optionModifiers).forEach((e=>t[e]=d.optionModifiers[e](t[e]))),this.options={},Object.keys(t).forEach((e=>this.options[e]=t[e])),"string"==typeof this.options.style&&(this.options.styleId=this.options.style,this.options.style=void 0),this.id=`${this.options.pathId}_${this.options.timestampId}`,"dynamic"===this.options.levelOfDetailMode?this.levelOfDetail=this.options.levelOfDetailMapper(this.zoom):this.levelOfDetail=this.options.levelOfDetail}getLayerInfo=()=>this.info.layerInfo;getFeatures=()=>this.options.loadAll?Object.values(this.loadingState.cache).map((t=>t[this.levelOfDetail-1])).filter((t=>t)):this.tiles.flatMap((t=>{const e=this.loadingState.featuresInTileCache[this.getTileId(t,this.levelOfDetail)]?.featureIds;return e?e.map((t=>{const e=this.loadingState.cache[t];return e&&e[this.levelOfDetail-1]})).filter((t=>t)):[]}));clearLayer=async()=>{await this.awaitNotLoading(),this.loadingState.cache={},this.loadingState.featuresInTileCache={},this.loadingState.nextPageStart=Array(6)};update=async()=>{if(this.loadingState.updateLock)return;this.options.debug("update.."),this.info.layerInfo||(this.loadingState.updateLock=!0,await this.fetchLayerInfo(),this.fetchStylingInfo(),this.loadingState.updateLock=!1,this.options.debug("fetched layer info:"),this.options.debug(this.info.layerInfo),this.options.debug("fetched style info:"),this.options.debug(this.info.style));const t=this.getMapBounds();if(!t)return;const e=this.options.maxZoom??this.options.zoom??this.info.layerInfo.zoom;this.zoom=Math.max(Math.min(e,t.zoom-2),0),"dynamic"===this.options.levelOfDetailMode&&(this.levelOfDetail=this.options.levelOfDetailMapper(t.zoom-2)),this.tiles=this.boundsToTiles(t.bounds,this.zoom),(!this.previousLevelOfDetail||this.previousLevelOfDetail!==this.levelOfDetail)&&"dynamic"===this.options.levelOfDetailMode&&(this.options.debug(`level of detail changed from ${this.previousLevelOfDetail} to ${this.levelOfDetail}`),this.previousLevelOfDetail=this.levelOfDetail,this.updateView()),this.load((()=>{this.updateView()}),this.options.fetchInterval)};load=async(t,e)=>{if(this.loadingState.loadingTimeout)return;if(this.loadingState.isLoading)return void(this.loadingState.missedCall=!0);this.loadingState.missedCall=!1,this.options.debug("load"),this.loadingState.isLoading=!0;const i=this.options.loadAll?await this.requestAllGeoJsons():await this.requestTileGeoJsons();return this.loadingState.isLoading=!1,this.loadingState.loadInterrupters.length?(this.loadingState.loadingTimeout=void 0,this.loadingState.loadInterrupters.forEach((t=>t())),void(this.loadingState.loadInterrupters=[])):i||this.loadingState.missedCall?(this.options.debug("loaded new data, page start: "+this.loadingState.nextPageStart),t(),void(this.loadingState.loadingTimeout=setTimeout((()=>{this.loadingState.loadingTimeout=void 0,this.load(t,e)}),e))):(this.options.debug("did not cache new data"),void this.ensureMaxCacheSize())};awaitNotLoading=t=>new Promise(((e,i)=>this.loadingState.loadingTimeout||this.loadingState.isLoading?this.loadingState.isLoading?this.loadingState.loadInterrupters.push((()=>e())):this.loadingState.loadingTimeout?(clearTimeout(this.loadingState.loadingTimeout),this.loadingState.loadingTimeout=void 0,t?e():setTimeout((()=>e()),this.options.fetchInterval)):void i():e()));ensureMaxCacheSize=()=>{if(void 0===this.options.maxTilesInCache)return;const t=Object.keys(this.loadingState.featuresInTileCache);if(t.length>this.options.maxTilesInCache){this.options.debug("There are too many tiles in the cache, removing the oldest ones.");const e=t.map((t=>this.loadingState.featuresInTileCache[t].date)).sort()[9];t.forEach((t=>{if(this.loadingState.featuresInTileCache[t].date<=e){const e=this.loadingState.featuresInTileCache[t].featurIds??[],i=[],o=this.loadingState.featuresInTileCache[t];Object.entries(this.loadingState.featuresInTileCache).forEach((([a,s])=>{a!==t&&s.levelOfDetail===o.levelOfDetail&&e.forEach((t=>{s.featureIds.includes(t)&&!i.includes(t)&&i.push(t)}))})),e.filter((t=>!i.includes(t))).forEach((t=>{delete this.loadingState.cache[t][o.levelOfDetail-1]})),delete this.loadingState.featuresInTileCache[t]}}))}};requestAllGeoJsons=async()=>{const t=this.levelOfDetail;if(4===this.loadingState.nextPageStart[t-1])return!1;const e={pageStart:this.loadingState.nextPageStart[t-1],returnType:this.getReturnType(),zipTheResponse:!0,pageSize:Math.min(3e3,this.options.pageSize),styleId:this.options.styleId,style:this.options.style,levelOfDetail:6===this.levelOfDetail?void 0:this.levelOfDetail};try{const i=await r.get(`/path/${this.options.pathId}/vector/timestamp/${this.info.layerInfo.id}/listFeatures`,e,{token:this.options.token});this.loadingState.nextPageStart[t-1]=i.nextPageStart,i.nextPageStart||(this.loadingState.nextPageStart[t-1]=4),i.result&&i.result.features&&i.result.features.forEach((e=>{this.compileStyle(e),this.loadOptions.onEachFeature&&this.loadOptions.onEachFeature(e),this.loadingState.cache[e.properties.id]||(this.loadingState.cache[e.properties.id]=Array(6)),this.loadingState.cache[e.properties.id][t-1]=e}))}catch(t){return console.error("an error occured with getting all features"),console.error(t),!1}return!0};requestTileGeoJsons=async()=>{const t=Date.now(),e=this.levelOfDetail,i=this.tiles.map((t=>{const i=this.getTileId(t,e);if(!this.loadingState.featuresInTileCache[i])return{tileId:t,levelOfDetail:6===e?void 0:e};const o=this.loadingState.featuresInTileCache[i].nextPageStart;return o&&this.loadingState.featuresInTileCache[i].amount<=this.options.maxFeaturesPerTile&&this.loadingState.featuresInTileCache[i].size<=this.options.maxMbPerTile?{tileId:t,pageStart:o,levelOfDetail:6===e?void 0:e}:null})).filter((t=>t));if(0===i.length)return!1;const o={returnType:this.getReturnType(),zipTheResponse:!0,pageSize:this.options.pageSize,styleId:this.options.styleId,style:this.options.style,propertyFilter:this.options.filter&&this.options.filter>0?this.options.filter:null};let a=[];const s=this.options.chunkSize;for(let t=0;t<i.length;t+=s){o.tiles=i.slice(t,t+s);try{const t=await r.get(`/path/${this.options.pathId}/vector/timestamp/${this.info.layerInfo.id}/featuresByTiles`,o,{token:this.options.token});a=a.concat(t)}catch(t){return console.error("an error occured with getting tile features"),console.error(t),!1}}for(let o=0;o<i.length;o++){const s=this.getTileId(i[o].tileId,e);this.loadingState.featuresInTileCache[s]||(this.loadingState.featuresInTileCache[s]={size:0,amount:0,featureIds:[],nextPageStart:null});const l=this.loadingState.featuresInTileCache[s];l.date=t,l.size=l.size+a[o].size,l.amount=l.amount+a[o].result.features.length,l.levelOfDetail=e,l.nextPageStart=a[o].nextPageStart,a[o].result.features&&a[o].result.features.forEach((t=>{this.compileStyle(t),this.loadOptions.onEachFeature&&this.loadOptions.onEachFeature(t)})),l.featureIds.push(...a[o].result.features.map((t=>t.properties.id))),a[o].result.features.forEach((t=>{const i=t.properties.id;this.loadingState.cache[i]||(this.loadingState.cache[i]=new Array(6)),this.loadingState.cache[i][e-1]||(t.lod=e-1,this.loadingState.cache[i][e-1]=t)}))}return!0};fetchLayerInfo=async()=>{const t=await r.getPath(this.options.pathId,{token:this.options.token});if(!t?.vector?.timestamps?.length)throw new h(`Specified path "${this.options.pathId}" does not contain any data.`);if(t.trashed&&console.warn("Path is trashed."),"vector"!==t.type)throw new h("Path info type is not vector.");const e=t.vector.timestamps;this.info.pathStyles=t.vector.styles;const i=e?.reverse().find((t=>!t.trashed&&!t.availability.blocked&&"active"===t.status));if(!this.options.timestampId&&i)return this.info.layerInfo=i,void this.options.debug(`No timestamp ID specified. Picked default ${i.id}`);const o=e.find((t=>t.id===this.options.timestampId));if(o)this.info.layerInfo=o;else{if(!o&&i)return this.info.layerInfo=i,void this.options.debug(`No correct timestamp ID specified. Picked default ${i.id}`);if(!o&&!i)throw new h(`Specified timestamp with id=${this.options.timestampId} does not exist and the path has no default timestamp to use as a fallback.`)}};fetchStylingInfo=()=>{const t=g({blacklist:["radius"]});if(!this.options.styleId&&this.options.style)return void(this.info.style=y(this.options.style.parameters,t));if(!this.info.pathStyles?.length)throw this.info.style=void 0,new h("The layer has no style.");const e=this.info.pathStyles.find((t=>t.id===this.options.styleId||t.default&&!this.options.styleId));this.info.style=e&&e.parameters?y(e.parameters,t):void 0};getReturnType=()=>this.options.centerPoints?"center":this.info.style?.popupProperty?"all":"geometry";recompileStyles=()=>{this.getFeatures().forEach((t=>this.compileStyle(t)))};compileStyle=t=>{let e=I(t,this.info.style,this.options);e=y(e,this.loadOptions.styleKeys),t.properties||(t.properties={}),t.properties.compiledStyle=e};getTileId=(t,e=this.levelOfDetail)=>`${t.zoom}_${t.tileX}_${t.tileY}_${e}`;boundsToTiles=(t,e)=>{const i=Math.max(t.xMin,-180),o=Math.min(t.xMax,180),a=Math.max(t.yMin,-85),s=Math.min(t.yMax,85),l=Math.pow(2,e),n=l/360,r=Math.PI,h=2*r,d=r/4,p=Math.floor((i+180)*n),c=Math.floor((o+180)*n),f=Math.floor(l/h*(r-Math.log(Math.tan(d+s/360*r)))),u=Math.floor(l/h*(r-Math.log(Math.tan(d+a/360*r))));let g=[];for(let t=Math.max(0,p-1);t<=Math.min(2**e-1,c+1);t++)for(let i=Math.max(0,f-1);i<=Math.min(2**e-1,u+1);i++)g.push({zoom:e,tileX:t,tileY:i});return g}}const p=d,c=(...t)=>{let e=t[t.length-2],i=t[t.length-1];void 0===e&&(e={}),void 0===i&&(i={});const o=Object.fromEntries(Object.keys({...e,...i}).map((t=>[t,void 0===i[t]?e[t]:i[t]])));return t.length>2?c(...t.slice(0,t.length-2),o):o},f={radius:6,width:2,borderColor:"#000000",borderOpacity:1,fillColor:"#000000",fillOpacity:.5},u={radius:[],width:["lineWidth","weight"],borderColor:[],borderOpacity:[],fillColor:["color"],fillOpacity:["opacity"],popupProperty:[]},g=(t={blacklist:[]})=>Object.fromEntries(Object.entries(u).filter((([e])=>!(t.blacklist.includes(e)||t.whitelist&&!t.whitelist.includes(e))))),m=(t,e)=>{if(!t)return;const i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(t);let[o,a,s,l]=i.slice(1).map((t=>parseInt(t,16)));return l=isNaN(l)?l=void 0:l/=255,e?{r:o,g:a,b:s,opacity:l}:{color:`#${i.slice(1,4).join("")}`,opacity:l}},y=(t={},e=u)=>{const i={};return Object.entries(t).forEach((([t,o])=>{const a=Object.entries(e).filter((([e,i])=>e===t||i&&i.includes(t)));a&&a.length&&a.forEach((([t])=>i[t]=o))})),i},I=(t,...e)=>{const i=t&&t.properties?y(t.properties):void 0;let o=c(i,...e.map((t=>t?y(t):void 0))),a=m(o.borderColor),s=m(o.fillColor);return a&&!s&&(s={...a},a.opacity=1),!a&&s&&(a={...s},a.opacity=1),a&&(o=c({fillOpacity:s.opacity,borderOpacity:a.opacity},o,{fillColor:s.color,borderColor:a.color})),c(f,o)};class S extends Error{constructor(t){super(t),this.name="EllipsisRasterLayerError"}}const v=(t={})=>{const e=l({token:t.token,style:t.style??t.layer??t.visualizationId??t.visualization,mask:t.mask});return`${r.getApiUrl()}/path/${t.pathId??t.blockId}/raster/timestamp/${t.timestampId??t.captureId}/tile/{z}/{x}/{y}${e}`},b=async(t={})=>{const e={token:t.token,style:t.style??t.layer??t.visualizationId??t.visualization,mask:t.mask};let i=t.timestampId??t.captureId;const o=t.pathId??t.blockId;let a=t.maxZoom??t.zoom;if(!i||!e.style||!a){const t=await r.getPath(o,{token:e.token});if(!t)throw new S(`Could not fetch data of path with id ${o}`);if("raster"!==t.type)throw new S("Path is not of type raster");if(!i){if(!t.raster?.timestamps?.length)throw new S("There are no timestamps in this path");const e=t.raster.timestamps.reverse().find((t=>!t.availability.blocked&&!t.trashed&&"active"===t.status));if(!e)throw new S("Could not find a valid default timestamp.");i=e.id}if(!a){let e=t.raster.timestamps.find((t=>t.id===i));if(!e)throw new S("Given timestampId does not exist");a=e.zoom}if(!e.style){const i=t.raster.styles?.find((t=>t.default));if(!i)throw new S("No default style found");e.style=i.id}}let s=`${r.getApiUrl()}/path/${o}/raster/timestamp/${i}/tile/{z}/{x}/{y}${l(e)}`;return{zoom:a,url:s,id:s+"_"+a}},O=(t={})=>`${t.pathId??t.blockId}_${t.timestampId??t.captureId}_${encodeURIComponent(JSON.stringify(t.style??t.visualizationId??t.visualization))}`;return e})()));